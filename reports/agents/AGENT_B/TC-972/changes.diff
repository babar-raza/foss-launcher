diff --git a/src/launch/workers/w4_ia_planner/worker.py b/src/launch/workers/w4_ia_planner/worker.py
index fbfb939..9fbb915 100644
--- a/src/launch/workers/w4_ia_planner/worker.py
+++ b/src/launch/workers/w4_ia_planner/worker.py
@@ -51,6 +51,144 @@ from ...util.logging import get_logger
 logger = get_logger()
 
 
+def assign_page_role(section: str, slug: str, is_index: bool = False) -> str:
+    """Assign page role based on section, slug, and type.
+
+    Implements content distribution strategy from specs/08_content_distribution_strategy.md.
+
+    Args:
+        section: Section name (products, docs, reference, kb, blog)
+        slug: Page slug
+        is_index: True if this is an index/TOC page (_index.md)
+
+    Returns:
+        Page role string (landing, toc, comprehensive_guide, workflow_page,
+        feature_showcase, troubleshooting, api_reference)
+    """
+    # TOC page detection (docs section index)
+    if is_index and section == "docs":
+        return "toc"
+
+    # Comprehensive guide detection (developer-guide pages)
+    if slug == "developer-guide" or slug.endswith("/developer-guide"):
+        return "comprehensive_guide"
+
+    # Landing page detection (products overview, blog posts)
+    if slug in ["overview", "index", "_index"] and section == "products":
+        return "landing"
+
+    # Section-specific role assignment
+    if section == "docs":
+        return "workflow_page"
+
+    if section == "kb":
+        # Feature showcase detection (how-to or showcase in slug)
+        if "how-to" in slug or "showcase" in slug:
+            return "feature_showcase"
+        return "troubleshooting"
+
+    if section == "reference":
+        return "api_reference"
+
+    if section == "blog":
+        return "landing"
+
+    # Default fallback
+    return "landing"
+
+
+def build_content_strategy(
+    page_role: str,
+    section: str,
+    workflows: List[Dict[str, Any]] = None,
+) -> Dict[str, Any]:
+    """Build content distribution strategy based on page role.
+
+    Implements content strategy rules from specs/08_content_distribution_strategy.md.
+
+    Args:
+        page_role: Page role (landing, toc, comprehensive_guide, etc.)
+        section: Section name (products, docs, reference, kb, blog)
+        workflows: List of workflows from product_facts (needed for comprehensive_guide)
+
+    Returns:
+        Content strategy dictionary with primary_focus, forbidden_topics,
+        claim_quota (min/max), child_pages (for toc), scenario_coverage (for comprehensive_guide)
+    """
+    if workflows is None:
+        workflows = []
+
+    strategy = {}
+
+    # Landing page (products)
+    if page_role == "landing" and section == "products":
+        strategy = {
+            "primary_focus": "Product positioning",
+            "forbidden_topics": ["detailed_api", "troubleshooting"],
+            "claim_quota": {"min": 5, "max": 10},
+        }
+
+    # TOC page
+    elif page_role == "toc":
+        strategy = {
+            "primary_focus": "Navigation hub",
+            "forbidden_topics": ["duplicate_child_content", "code_snippets"],
+            "claim_quota": {"min": 0, "max": 2},
+            "child_pages": [],  # Will be populated by post-processing
+        }
+
+    # Comprehensive guide
+    elif page_role == "comprehensive_guide":
+        strategy = {
+            "primary_focus": "All usage scenarios",
+            "forbidden_topics": ["installation", "troubleshooting"],
+            "claim_quota": {"min": len(workflows), "max": 50},
+            "scenario_coverage": "all",
+        }
+
+    # Workflow page
+    elif page_role == "workflow_page":
+        strategy = {
+            "primary_focus": "How-to guide",
+            "forbidden_topics": ["other_workflows"],
+            "claim_quota": {"min": 3, "max": 8},
+        }
+
+    # Feature showcase
+    elif page_role == "feature_showcase":
+        strategy = {
+            "primary_focus": "Prominent feature how-to",
+            "forbidden_topics": ["general_features", "api_reference", "other_features"],
+            "claim_quota": {"min": 3, "max": 8},
+        }
+
+    # Troubleshooting
+    elif page_role == "troubleshooting":
+        strategy = {
+            "primary_focus": "Problem-solution",
+            "forbidden_topics": ["features", "installation"],
+            "claim_quota": {"min": 1, "max": 5},
+        }
+
+    # Landing page (blog)
+    elif page_role == "landing" and section == "blog":
+        strategy = {
+            "primary_focus": "Synthesized overview",
+            "forbidden_topics": [],
+            "claim_quota": {"min": 10, "max": 20},
+        }
+
+    # Default fallback (minimal strategy)
+    else:
+        strategy = {
+            "primary_focus": f"{section} page content",
+            "forbidden_topics": [],
+            "claim_quota": {"min": 1, "max": 10},
+        }
+
+    return strategy
+
+
 class IAPlannerError(Exception):
     """Base exception for W4 IAPlanner errors."""
     pass
@@ -536,6 +674,10 @@ def plan_pages_for_section(
         title = f"{product_facts.get('product_name', 'Product')} Overview"
         purpose = "Product overview and positioning"
 
+        # Assign page role and build content strategy
+        products_role = assign_page_role("products", slug)
+        products_strategy = build_content_strategy(products_role, "products", workflows)
+
         # Select claims for overview (positioning, features)
         overview_claim_ids = [
             c["claim_id"] for c in claims[:10]  # Take first 10 claims
@@ -556,62 +698,111 @@ def plan_pages_for_section(
             "required_snippet_tags": snippet_tags[:2] if snippet_tags else [],
             "cross_links": [],  # Will be populated after all pages are planned
             "seo_keywords": [product_slug, platform, "overview"],
-            "forbidden_topics": []
+            "forbidden_topics": products_strategy.get("forbidden_topics", []),
+            "page_role": products_role,
+            "content_strategy": products_strategy,
         })
 
     elif section == "docs":
-        # Docs section: how-to guides based on workflows
-        max_pages = 1 if launch_tier == "minimal" else (3 if launch_tier == "standard" else 5)
+        # Docs section: TOC + getting-started + developer-guide (comprehensive)
+        # Per TC-972: Create exactly 3 pages with proper page_role and content_strategy
+
+        # Page 1: TOC (_index.md) - Navigation hub
+        toc_role = assign_page_role("docs", "_index", is_index=True)
+        toc_strategy = build_content_strategy(toc_role, "docs", workflows)
+        pages.append({
+            "section": section,
+            "slug": "_index",
+            "output_path": compute_output_path(section, "_index", product_slug, platform=platform),
+            "url_path": compute_url_path(section, "_index", product_slug, platform=platform),
+            "title": f"{product_facts.get('product_name', 'Product')} Documentation",
+            "purpose": "Table of contents and navigation hub",
+            "template_variant": launch_tier,
+            "required_headings": ["Introduction", "Documentation Index", "Quick Links"],
+            "required_claim_ids": [c["claim_id"] for c in claims[:2]],  # Brief intro only
+            "required_snippet_tags": [],  # No code on TOC
+            "cross_links": [],
+            "seo_keywords": [product_slug, platform, "documentation"],
+            "forbidden_topics": toc_strategy.get("forbidden_topics", []),
+            "page_role": toc_role,
+            "content_strategy": toc_strategy,
+        })
+
+        # Page 2: Getting Started - Installation and first task
+        gs_role = assign_page_role("docs", "getting-started")
+        gs_strategy = build_content_strategy(gs_role, "docs", workflows)
+
+        # Select install and quickstart claims
+        install_quickstart_claims = [
+            c["claim_id"] for c in claims
+            if c.get("claim_group", "").lower() in ["install_steps", "quickstart_steps", "installation", "quickstart"]
+        ][:5]
 
-        # Create getting-started page
         pages.append({
             "section": section,
             "slug": "getting-started",
             "output_path": compute_output_path(section, "getting-started", product_slug, platform=platform),
             "url_path": compute_url_path(section, "getting-started", product_slug, platform=platform),
             "title": "Getting Started",
-            "purpose": "Installation and basic usage guide",
+            "purpose": "Installation instructions and first task guide",
             "template_variant": launch_tier,
             "required_headings": ["Installation", "Basic Usage", "Prerequisites", "Next Steps"],
-            "required_claim_ids": [c["claim_id"] for c in claims[:3]],
+            "required_claim_ids": install_quickstart_claims if install_quickstart_claims else [c["claim_id"] for c in claims[:3]],
             "required_snippet_tags": snippet_tags[:1] if snippet_tags else [],
             "cross_links": [],
             "seo_keywords": [product_slug, platform, "getting started"],
-            "forbidden_topics": []
+            "forbidden_topics": gs_strategy.get("forbidden_topics", []),
+            "page_role": gs_role,
+            "content_strategy": gs_strategy,
         })
 
-        # Create workflow-based guides
-        for i, workflow in enumerate(workflows[:max_pages - 1]):
-            slug = workflow.get("workflow_id", f"guide-{i+1}").lower().replace("_", "-")
-            title = workflow.get("name", f"Guide {i+1}")
+        # Page 3: Developer Guide - Comprehensive listing of ALL scenarios
+        dg_role = assign_page_role("docs", "developer-guide")
+        dg_strategy = build_content_strategy(dg_role, "docs", workflows)
 
-            # Find claims related to this workflow
-            workflow_claim_ids = [
+        # Gather one claim per workflow
+        workflow_claim_ids = []
+        for workflow in workflows:
+            wf_id = workflow.get("workflow_id", "")
+            # Find first claim matching this workflow
+            matching_claims = [
                 c["claim_id"] for c in claims
-                if workflow.get("workflow_id") in c.get("claim_group", "")
-            ][:5]
+                if wf_id in c.get("claim_group", "") or wf_id in c.get("tags", [])
+            ]
+            if matching_claims:
+                workflow_claim_ids.append(matching_claims[0])
 
-            pages.append({
-                "section": section,
-                "slug": slug,
-                "output_path": compute_output_path(section, slug, product_slug, platform=platform),
-                "url_path": compute_url_path(section, slug, product_slug, platform=platform),
-                "title": title,
-                "purpose": workflow.get("description", f"How-to guide for {title}"),
-                "template_variant": launch_tier,
-                "required_headings": ["Overview", "Steps", "Example", "Troubleshooting"],
-                "required_claim_ids": workflow_claim_ids,
-                "required_snippet_tags": snippet_tags[:2] if snippet_tags else [],
-                "cross_links": [],
-                "seo_keywords": [product_slug, platform, slug],
-                "forbidden_topics": []
-            })
+        # Fallback: if no workflow-specific claims found, use first N claims
+        if not workflow_claim_ids and workflows:
+            workflow_claim_ids = [c["claim_id"] for c in claims[:len(workflows)]]
+
+        pages.append({
+            "section": section,
+            "slug": "developer-guide",
+            "output_path": compute_output_path(section, "developer-guide", product_slug, platform=platform),
+            "url_path": compute_url_path(section, "developer-guide", product_slug, platform=platform),
+            "title": "Developer Guide - All Usage Scenarios",
+            "purpose": "Comprehensive listing of all major usage scenarios with source code",
+            "template_variant": launch_tier,
+            "required_headings": ["Introduction", "Common Scenarios", "Advanced Scenarios", "Additional Resources"],
+            "required_claim_ids": workflow_claim_ids,
+            "required_snippet_tags": sorted(set(snippet_tags)),  # All snippets
+            "cross_links": [],
+            "seo_keywords": [product_slug, platform, "developer guide", "scenarios"],
+            "forbidden_topics": dg_strategy.get("forbidden_topics", []),
+            "page_role": dg_role,
+            "content_strategy": dg_strategy,
+        })
 
     elif section == "reference":
         # Reference section: API overview
         slug = "api-overview"
         api_summary = product_facts.get("api_surface_summary", {})
 
+        # Assign page role and build content strategy
+        ref_role = assign_page_role("reference", slug)
+        ref_strategy = build_content_strategy(ref_role, "reference", workflows)
+
         pages.append({
             "section": section,
             "slug": slug,
@@ -625,7 +816,9 @@ def plan_pages_for_section(
             "required_snippet_tags": snippet_tags[:1] if snippet_tags else [],
             "cross_links": [],
             "seo_keywords": [product_slug, platform, "api", "reference"],
-            "forbidden_topics": []
+            "forbidden_topics": ref_strategy.get("forbidden_topics", []),
+            "page_role": ref_role,
+            "content_strategy": ref_strategy,
         })
 
         # For standard/rich tiers, add module pages
@@ -633,6 +826,8 @@ def plan_pages_for_section(
             modules = api_summary.get("key_modules", [])[:2 if launch_tier == "standard" else 3]
             for module in modules:
                 slug = module.lower().replace(".", "-")
+                module_role = assign_page_role("reference", slug)
+                module_strategy = build_content_strategy(module_role, "reference", workflows)
                 pages.append({
                     "section": section,
                     "slug": slug,
@@ -646,11 +841,64 @@ def plan_pages_for_section(
                     "required_snippet_tags": snippet_tags[:1] if snippet_tags else [],
                     "cross_links": [],
                     "seo_keywords": [product_slug, platform, module],
-                    "forbidden_topics": []
+                    "forbidden_topics": module_strategy.get("forbidden_topics", []),
+                    "page_role": module_role,
+                    "content_strategy": module_strategy,
                 })
 
     elif section == "kb":
-        # KB section: FAQ, troubleshooting, limitations
+        # KB section: Feature showcases (2-3) + troubleshooting (1-2)
+        # Per TC-972: Create feature showcase articles for prominent features + troubleshooting pages
+
+        # Feature showcase selection: Get key_features claims with snippet coverage
+        key_feature_claims = [
+            c for c in claims
+            if c.get("claim_group", "").lower() in ["key_features", "features"]
+        ]
+
+        # Determine showcase count based on tier
+        showcase_count = 2 if launch_tier == "minimal" else 3
+
+        # Create feature showcase pages
+        for i, feature_claim in enumerate(key_feature_claims[:showcase_count]):
+            # Generate slug from feature text
+            feature_text = feature_claim.get("claim_text", f"feature-{i+1}")
+            slug = f"how-to-{feature_text[:40].lower().replace(' ', '-').replace('/', '-').replace('.', '')}"
+
+            # Check if snippets exist with matching tags
+            feature_tags = feature_claim.get("tags", [])
+            matching_snippets = [
+                s for s in snippets
+                if any(tag in s.get("tags", []) for tag in feature_tags)
+            ]
+
+            # Only create showcase if feature has code examples
+            if matching_snippets or snippets:  # Fallback to any snippet if no exact match
+                showcase_role = assign_page_role("kb", slug)
+                showcase_strategy = build_content_strategy(showcase_role, "kb", workflows)
+
+                pages.append({
+                    "section": "kb",
+                    "slug": slug,
+                    "output_path": compute_output_path("kb", slug, product_slug, platform=platform),
+                    "url_path": compute_url_path("kb", slug, product_slug, platform=platform),
+                    "title": f"How to: {feature_text[:50]}",
+                    "purpose": f"Feature showcase for {feature_text[:50]}",
+                    "template_variant": launch_tier,
+                    "required_headings": ["Overview", "When to Use", "Step-by-Step Guide", "Code Example", "Related Links"],
+                    "required_claim_ids": [feature_claim["claim_id"]],  # Single feature focus
+                    "required_snippet_tags": [matching_snippets[0].get("tags", [""])[0]] if matching_snippets else (snippet_tags[:1] if snippet_tags else []),
+                    "cross_links": [],
+                    "seo_keywords": [product_slug, platform, "how-to", slug.replace("how-to-", "")],
+                    "forbidden_topics": showcase_strategy.get("forbidden_topics", []),
+                    "page_role": showcase_role,
+                    "content_strategy": showcase_strategy,
+                })
+
+        # Troubleshooting pages
+        # FAQ (always created)
+        faq_role = assign_page_role("kb", "faq")
+        faq_strategy = build_content_strategy(faq_role, "kb", workflows)
         pages.append({
             "section": "kb",
             "slug": "faq",
@@ -664,10 +912,15 @@ def plan_pages_for_section(
             "required_snippet_tags": [],
             "cross_links": [],
             "seo_keywords": [product_slug, platform, "faq"],
-            "forbidden_topics": []
+            "forbidden_topics": faq_strategy.get("forbidden_topics", []),
+            "page_role": faq_role,
+            "content_strategy": faq_strategy,
         })
 
+        # Troubleshooting guide (standard/rich tiers only)
         if launch_tier in ["standard", "rich"]:
+            ts_role = assign_page_role("kb", "troubleshooting")
+            ts_strategy = build_content_strategy(ts_role, "kb", workflows)
             pages.append({
                 "section": "kb",
                 "slug": "troubleshooting",
@@ -681,27 +934,16 @@ def plan_pages_for_section(
                 "required_snippet_tags": [],
                 "cross_links": [],
                 "seo_keywords": [product_slug, platform, "troubleshooting"],
-                "forbidden_topics": []
-            })
-
-            pages.append({
-                "section": "kb",
-                "slug": "limitations",
-                "output_path": compute_output_path("kb", "limitations", product_slug, platform=platform),
-                "url_path": compute_url_path("kb", "limitations", product_slug, platform=platform),
-                "title": "Known Limitations",
-                "purpose": "Known limitations and workarounds",
-                "template_variant": launch_tier,
-                "required_headings": ["Overview", "Platform Limitations", "Workarounds"],
-                "required_claim_ids": [],
-                "required_snippet_tags": [],
-                "cross_links": [],
-                "seo_keywords": [product_slug, platform, "limitations"],
-                "forbidden_topics": []
+                "forbidden_topics": ts_strategy.get("forbidden_topics", []),
+                "page_role": ts_role,
+                "content_strategy": ts_strategy,
             })
 
     elif section == "blog":
         # Blog section: announcement post
+        blog_role = assign_page_role("blog", "announcement")
+        blog_strategy = build_content_strategy(blog_role, "blog", workflows)
+
         pages.append({
             "section": "blog",
             "slug": "announcement",
@@ -715,7 +957,9 @@ def plan_pages_for_section(
             "required_snippet_tags": snippet_tags[:1] if snippet_tags else [],
             "cross_links": [],
             "seo_keywords": [product_slug, platform, "announcement"],
-            "forbidden_topics": []
+            "forbidden_topics": blog_strategy.get("forbidden_topics", []),
+            "page_role": blog_role,
+            "content_strategy": blog_strategy,
         })
 
     return pages
@@ -1110,21 +1354,25 @@ def generate_content_tokens(
 ) -> Dict[str, str]:
     """Generate content-specific placeholder token values.
 
-    TC-964: For template-driven pages (especially blog), creates deterministic
-    token values for title, description, author, date, and body content.
+    TC-964: For blog templates, creates deterministic token values for
+    title, description, author, date, and body content (20 tokens).
+
+    TC-970: Extended to support docs/products/reference/kb templates with
+    97 additional tokens including enable flags, metadata, body blocks,
+    code blocks, FAQ content, and plugin/product information.
 
-    This function generates all tokens needed to fill blog template frontmatter
+    This function generates all tokens needed to fill template frontmatter
     and body placeholders, ensuring deterministic output for VFV verification.
 
     Args:
         page_spec: Page specification dict
-        section: Section name (e.g., "blog")
+        section: Section name (e.g., "blog", "docs", "products", "reference", "kb")
         family: Product family (e.g., "3d", "note")
         platform: Platform name (e.g., "python", "net")
         locale: Language code (default: "en")
 
     Returns:
-        Dict mapping token names to filled values
+        Dict mapping token names to filled values (20 for blog, 97+ for docs)
 
     Raises:
         ValueError: If required fields missing from page_spec
@@ -1199,6 +1447,113 @@ def generate_content_tokens(
 
     tokens["__BODY_SEE_ALSO__"] = f"For more information, see the {product_name} API reference and additional tutorials."
 
+    # TC-970: Docs/Products/Reference/KB tokens
+    # Generate 97 additional tokens for documentation templates
+    if section in ["docs", "products", "reference", "kb"]:
+        # ENABLE FLAGS (boolean string values for Hugo YAML frontmatter)
+        tokens["__FAQ_ENABLE__"] = "true"
+        tokens["__OVERVIEW_ENABLE__"] = "true"
+        tokens["__BODY_ENABLE__"] = "true"
+        tokens["__MORE_FORMATS_ENABLE__"] = "true" if section == "products" else "false"
+        tokens["__SUBMENU_ENABLE__"] = "false"  # Minimal tier
+        tokens["__SUPPORT_AND_LEARNING_ENABLE__"] = "true"
+        tokens["__BACK_TO_TOP_ENABLE__"] = "true"
+        tokens["__SUPPORT_ENABLE__"] = "true"
+        tokens["__SINGLE_ENABLE__"] = "true" if section == "reference" else "false"
+        tokens["__TESTIMONIALS_ENABLE__"] = "false"  # Minimal tier
+        tokens["__BUTTON_ENABLE__"] = "false"  # Minimal tier
+
+        # HEAD METADATA (complementing existing __SEO_TITLE__ from blog section)
+        tokens["__HEAD_TITLE__"] = f"{product_name} - {slug.replace('-', ' ').title()}"
+        tokens["__HEAD_DESCRIPTION__"] = f"Learn how to use {product_name} for {slug.replace('-', ' ')}. Comprehensive documentation and API reference."
+
+        # PAGE CONTENT
+        tokens["__PAGE_TITLE__"] = slug.replace('-', ' ').title()
+        tokens["__PAGE_DESCRIPTION__"] = f"Documentation for {product_name}"
+        tokens["__OVERVIEW_TITLE__"] = "Overview"
+        tokens["__OVERVIEW_CONTENT__"] = f"This section covers {slug.replace('-', ' ')} in {product_name}. Learn about features, usage, and best practices."
+        tokens["__SUBTITLE__"] = f"{slug.replace('-', ' ').title()} Reference"
+        tokens["__LINK_TITLE__"] = slug.replace('-', ' ').title()
+        tokens["__LINKTITLE__"] = slug.replace('-', ' ').title()
+
+        # BODY BLOCKS (structured content sections)
+        tokens["__BODY_API_OVERVIEW__"] = f"The {product_name} API provides comprehensive access to {family} functionality."
+        tokens["__BODY_FEATURES__"] = f"Key features include file format support, rendering capabilities, and platform integration."
+        tokens["__BODY_GETTING_STARTED__"] = f"To get started with {product_name}, install the package and import the necessary modules."
+        tokens["__BODY_EXAMPLES__"] = f"The following examples demonstrate common {family} operations in {platform}."
+        tokens["__BODY_GUIDES__"] = f"Explore detailed guides for working with {family} files in your {platform} applications."
+        tokens["__BODY_QUICKSTART__"] = f"Quick start guide for {product_name} in {platform}."
+        tokens["__BODY_IN_THIS_SECTION__"] = f"This section covers essential topics for {product_name} development."
+        tokens["__BODY_NEXT_STEPS__"] = f"Next, explore advanced features and integration options for {product_name}."
+        tokens["__BODY_RELATED_LINKS__"] = f"Related documentation: API reference, tutorials, and examples."
+        tokens["__BODY_SUPPORT__"] = f"Get support for {product_name} through documentation, forums, and technical assistance."
+        tokens["__BODY_FAQ__"] = f"Frequently asked questions about {product_name}."
+        tokens["__BODY_USECASES__"] = f"Common use cases for {product_name} in {platform} applications."
+        tokens["__BODY_USAGE_SNIPPET__"] = f"Basic usage example for {product_name}."
+        tokens["__BODY_SYMPTOMS__"] = f"N/A"
+
+        # BODY BLOCKS (left/right column layout)
+        tokens["__BODY_BLOCK_TITLE_LEFT__"] = "Features"
+        tokens["__BODY_BLOCK_CONTENT_LEFT__"] = f"{product_name} provides comprehensive {family} file processing capabilities for {platform} applications."
+        tokens["__BODY_BLOCK_TITLE_RIGHT__"] = "Getting Started"
+        tokens["__BODY_BLOCK_CONTENT_RIGHT__"] = f"Install {product_name} via package manager and explore the API documentation to begin development."
+
+        # BODY BLOCKS (reference/API specific)
+        tokens["__BODY_NAMESPACE__"] = f"Aspose.{family.capitalize()}"
+        tokens["__BODY_KEY_NAMESPACES__"] = f"Aspose.{family.capitalize()}, Aspose.{family.capitalize()}.Entities"
+        tokens["__BODY_KEY_SYMBOLS__"] = f"Scene, Entity, Node"
+        tokens["__BODY_POPULAR_CLASSES__"] = f"Scene, Entity, Mesh, Node"
+        tokens["__BODY_SIGNATURE__"] = f"public class Scene"
+        tokens["__BODY_PARAMETERS__"] = f"No parameters"
+        tokens["__BODY_RETURNS__"] = f"Returns a Scene object"
+        tokens["__BODY_REMARKS__"] = f"Use Scene class as the entry point for {family} operations."
+        tokens["__BODY_PURPOSE__"] = f"Provides {family} file processing functionality"
+        tokens["__BODY_CAUSE__"] = f"N/A"
+        tokens["__BODY_RESOLUTION__"] = f"Refer to documentation for troubleshooting guidance"
+
+        # CODE BLOCKS (placeholder GitHub gist references - deterministic hash)
+        gist_hash = hashlib.md5(f"{family}_{platform}_{slug}".encode()).hexdigest()[:12]
+        tokens["__BODY_BLOCK_GIST_HASH__"] = gist_hash
+        tokens["__BODY_BLOCK_GIST_FILE__"] = f"{slug.replace('-', '_')}_example.py"
+        tokens["__SINGLE_GIST_HASH__"] = gist_hash
+        tokens["__SINGLE_GIST_FILE__"] = f"{slug.replace('-', '_')}_sample.py"
+        tokens["__CODESAMPLES__"] = f"Code samples for {product_name} demonstrating {slug.replace('-', ' ')} operations."
+
+        # FAQ CONTENT
+        tokens["__FAQ_QUESTION__"] = f"How do I use {product_name} in my {platform} project?"
+        tokens["__FAQ_ANSWER__"] = f"Install {product_name} via package manager, import the library, and use the API to work with {family} files. See the getting started guide for detailed instructions."
+
+        # PLUGIN/PRODUCT METADATA
+        tokens["__PLUGIN_NAME__"] = product_name
+        tokens["__PLUGIN_DESCRIPTION__"] = f"{product_name} library for {platform} - comprehensive {family} file format support"
+        tokens["__PLUGIN_PLATFORM__"] = platform
+        tokens["__CART_ID__"] = f"aspose-{family}-{platform}"
+        tokens["__PRODUCT_NAME__"] = product_name
+        tokens["__REFERENCE_SLUG__"] = slug
+        tokens["__TOPIC_SLUG__"] = slug
+        tokens["__FAMILY__"] = family
+        tokens["__CASE_STUDIES_LINK__"] = f"/case-studies/{family}/"
+
+        # MISC TOKENS
+        tokens["__TOKEN__"] = ""  # Generic placeholder - empty string
+        tokens["__WEIGHT__"] = "10"  # Default weight for sidebar ordering
+        tokens["__SIDEBAR_OPEN__"] = "false"
+        tokens["__LOCALE__"] = locale
+        tokens["__LASTMOD__"] = "2024-01-01"  # Deterministic date
+        tokens["__SECTION_PATH__"] = f"/{section}/"
+        tokens["__UPPER_SNAKE__"] = slug.replace('-', '_').upper()
+        tokens["__ENHANCED__"] = "false"  # Minimal tier
+
+        # SINGLE PAGE CONTENT (for reference pages)
+        tokens["__SINGLE_TITLE__"] = f"{slug.replace('-', ' ').title()} Reference"
+        tokens["__SINGLE_CONTENT__"] = f"Detailed reference documentation for {slug.replace('-', ' ')} in {product_name}."
+
+        # TESTIMONIALS (disabled for minimal tier)
+        tokens["__TESTIMONIALS_TITLE__"] = "What Developers Say"
+        tokens["__TESTIMONIALS_SUBTITLE__"] = "Developer Feedback"
+        tokens["__TESTIMONIAL_MESSAGE__"] = f"{product_name} is a powerful library for {family} development."
+        tokens["__TESTIMONIAL_POSTER__"] = "Anonymous Developer"
+
     return tokens
 
 
@@ -1435,6 +1790,22 @@ def execute_ia_planner(
 
             logger.info(f"[W4 IAPlanner] Planned {len(selected)} pages for section: {section} (template-driven)")
 
+        # Populate child_pages for TOC pages
+        logger.info("[W4] Populating child_pages for TOC pages")
+        for page in all_pages:
+            if page.get("page_role") == "toc":
+                section = page["section"]
+                # Find all pages in same section (excluding TOC itself)
+                child_slugs = [
+                    p["slug"]
+                    for p in all_pages
+                    if p["section"] == section and p["slug"] != "_index"
+                ]
+                # Sort for deterministic ordering
+                child_slugs.sort()
+                page["content_strategy"]["child_pages"] = child_slugs
+                logger.debug(f"[W4] TOC page {section}/_index has {len(child_slugs)} children: {child_slugs}")
+
         # Add cross-links between pages
         add_cross_links(all_pages)
 
